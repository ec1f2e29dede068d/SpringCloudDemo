import com.netflix.config.ConfigurationManager;
import com.netflix.hystrix.HystrixCommand;
import com.netflix.hystrix.HystrixCommandGroupKey;
import com.netflix.hystrix.HystrixCommandMetrics;
import com.netflix.hystrix.HystrixCommandProperties;

public class OpenTest {

    public static void main(String[] args) {
        ConfigurationManager.getConfigInstance().setProperty(
                "hystrix.command.default.metrics.rollingStats.timeInMilliseconds", 10000);
        ConfigurationManager.getConfigInstance().setProperty(
                "hystrix.command.default.circuitBreaker.requestVolumeThreshold", 5);
        ConfigurationManager.getConfigInstance().setProperty(
                "hystrix.command.default.circuitBreaker.errorThresholdPercentage", 50);
        ConfigurationManager.getConfigInstance().setProperty(
                "hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds", 1000);

        boolean isTimeout = true;
        for (int i = 0; i < 15; i++) {
            MyCommand myCommand = new MyCommand(isTimeout);
            myCommand.execute();
            HystrixCommandMetrics.HealthCounts healthCounts = myCommand.getMetrics().getHealthCounts();
            System.out.println("断路器状态：" + myCommand.isCircuitBreakerOpen() + "，请求总数："
                    + healthCounts.getTotalRequests());
            if (myCommand.isCircuitBreakerOpen()) {
                isTimeout = false;
                System.out.println("===== 断路器打开了，等待休眠结束 =====");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

    }

    static class MyCommand extends HystrixCommand<String> {

        private boolean isTimeout;

        protected MyCommand(boolean isTimeout) {
            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"))
                    .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                            .withExecutionTimeoutInMilliseconds(500)));
            this.isTimeout = isTimeout;
        }

        @Override
        protected String run() throws Exception {
            if (isTimeout) {
                Thread.sleep(800);
            } else {
                Thread.sleep(200);
            }
            return "";
        }

        @Override
        protected String getFallback() {
            return "";
        }
    }
}
